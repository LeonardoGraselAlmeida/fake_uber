
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>usecase: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/leonardograselalmeida/fake_uber/internal/application/usecase/accept_ride.go (100.0%)</option>
				
				<option value="file1">github.com/leonardograselalmeida/fake_uber/internal/application/usecase/get_account.go (100.0%)</option>
				
				<option value="file2">github.com/leonardograselalmeida/fake_uber/internal/application/usecase/get_ride.go (100.0%)</option>
				
				<option value="file3">github.com/leonardograselalmeida/fake_uber/internal/application/usecase/request_ride.go (0.0%)</option>
				
				<option value="file4">github.com/leonardograselalmeida/fake_uber/internal/application/usecase/signup.go (0.0%)</option>
				
				<option value="file5">github.com/leonardograselalmeida/fake_uber/internal/application/usecase/start_ride.go (0.0%)</option>
				
				<option value="file6">github.com/leonardograselalmeida/fake_uber/internal/domain/entity/account.go (100.0%)</option>
				
				<option value="file7">github.com/leonardograselalmeida/fake_uber/internal/domain/entity/ride.go (86.7%)</option>
				
				<option value="file8">github.com/leonardograselalmeida/fake_uber/internal/domain/validate_cpf.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package usecase

import (
        "errors"

        "github.com/google/uuid"
        "github.com/leonardograselalmeida/fake_uber/internal/application/repository"
)

type AcceptRide struct {
        AccountRepository repository.AccountRepositoryInterface
        RideRepository    repository.RideRepositoryInterface
}

type AcceptRideInput struct {
        DriverId uuid.UUID
        RideId   uuid.UUID
}

func (a *AcceptRide) Execute(input AcceptRideInput) error <span class="cov8" title="1">{
        account, accountError := a.AccountRepository.GetAccountById(input.DriverId)

        if accountError != nil </span><span class="cov8" title="1">{
                return accountError
        }</span>

        <span class="cov8" title="1">if account == nil </span><span class="cov8" title="1">{
                return errors.New("driver not found")
        }</span>

        <span class="cov8" title="1">if !account.IsDriver </span><span class="cov8" title="1">{
                return errors.New("only drivers can accept a ride")
        }</span>

        <span class="cov8" title="1">ride, rideError := a.RideRepository.GetRideById(input.RideId)

        if rideError != nil </span><span class="cov8" title="1">{
                return rideError
        }</span>

        <span class="cov8" title="1">if ride == nil </span><span class="cov8" title="1">{
                return errors.New("ride not found")
        }</span>

        <span class="cov8" title="1">ride.Accept(input.DriverId)
        err := a.RideRepository.UpdateRide(ride)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package usecase

import (
        "github.com/google/uuid"
        "github.com/leonardograselalmeida/fake_uber/internal/application/repository"
        "github.com/leonardograselalmeida/fake_uber/internal/domain/entity"
)

type GetAccount struct {
        AccountRepository repository.AccountRepositoryInterface
}

func (g *GetAccount) Execute(accountId uuid.UUID) (*entity.Account, error) <span class="cov8" title="1">{
        account, err := g.AccountRepository.GetAccountById(accountId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return account, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package usecase

import (
        "errors"

        "github.com/google/uuid"
        "github.com/leonardograselalmeida/fake_uber/internal/application/logger"
        "github.com/leonardograselalmeida/fake_uber/internal/application/repository"
)

type GetRide struct {
        RideRepository repository.RideRepositoryInterface
        Logger         logger.LoggerInterface
}

type GetRideOutput struct {
        RideId      uuid.UUID
        Status      string
        DriverId    uuid.UUID
        PassengerId uuid.UUID
}

func (g *GetRide) Execute(rideId uuid.UUID) (*GetRideOutput, error) <span class="cov8" title="1">{
        g.Logger.Log("getRide")
        ride, rideError := g.RideRepository.GetRideById(rideId)

        if rideError != nil </span><span class="cov8" title="1">{
                return nil, rideError
        }</span>

        <span class="cov8" title="1">if ride == nil </span><span class="cov8" title="1">{
                return nil, errors.New("ride not found")
        }</span>

        <span class="cov8" title="1">output := GetRideOutput{
                RideId:      ride.RideId,
                Status:      ride.GetStatus(),
                DriverId:    ride.GetDriverId(),
                PassengerId: ride.PassengerId,
        }

        return &amp;output, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package usecase

import (
        "errors"

        "github.com/google/uuid"
        "github.com/leonardograselalmeida/fake_uber/internal/application/logger"
        "github.com/leonardograselalmeida/fake_uber/internal/application/repository"
        "github.com/leonardograselalmeida/fake_uber/internal/domain/entity"
)

type RequestRide struct {
        AccountRepository repository.AccountRepositoryInterface
        RideRepository    repository.RideRepositoryInterface
        Logger            logger.LoggerInterface
}

type RequestRideInput struct {
        PassengerId uuid.UUID
        FromLat     float64
        FromLong    float64
        ToLat       float64
        ToLong      float64
}

type RequestRideOutput struct {
        RideId uuid.UUID
}

func (r *RequestRide) Execute(input RequestRideInput) (*RequestRideOutput, error) <span class="cov0" title="0">{
        r.Logger.Log("requestRide")
        account, accountError := r.AccountRepository.GetAccountById(input.PassengerId)

        if accountError != nil </span><span class="cov0" title="0">{
                return nil, accountError
        }</span>
        <span class="cov0" title="0">if account == nil </span><span class="cov0" title="0">{
                return nil, errors.New("account does not exit")
        }</span>
        <span class="cov0" title="0">if !account.IsPassenger </span><span class="cov0" title="0">{
                return nil, errors.New("only passenger can request a ride")
        }</span>

        <span class="cov0" title="0">activeRide, activeRideError := r.RideRepository.GetActiveRideByPassengerId(input.PassengerId)

        if activeRideError != nil </span><span class="cov0" title="0">{
                return nil, activeRideError
        }</span>

        <span class="cov0" title="0">if activeRide != nil </span><span class="cov0" title="0">{
                return nil, errors.New("passenger has an active ride")
        }</span>

        <span class="cov0" title="0">ride := entity.CreateRide(input.PassengerId, input.FromLat, input.FromLong, input.ToLat, input.ToLong)

        r.RideRepository.SaveRide(ride)

        output := RequestRideOutput{
                RideId: ride.RideId,
        }

        return &amp;output, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package usecase

import (
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/leonardograselalmeida/fake_uber/internal/application/logger"
        "github.com/leonardograselalmeida/fake_uber/internal/application/repository"
        "github.com/leonardograselalmeida/fake_uber/internal/domain/entity"
)

type Signup struct {
        AccountRepository repository.AccountRepositoryInterface
        Logger            logger.LoggerInterface
}

type SignupInput struct {
        Name        string
        Email       string
        Cpf         string
        CarPlate    string
        IsPassenger bool
        IsDriver    bool
        Password    string
}

type SignupOutput struct {
        AccountId uuid.UUID
}

func (s *Signup) Execute(input SignupInput) (*SignupOutput, error) <span class="cov0" title="0">{
        messageLog := fmt.Sprintf("signup %s", input.Name)
        s.Logger.Log(messageLog)

        existingAccount, existingAccountError := s.AccountRepository.GetAccountByEmail(input.Email)

        if existingAccountError != nil </span><span class="cov0" title="0">{
                return nil, existingAccountError
        }</span>

        <span class="cov0" title="0">if existingAccount != nil </span><span class="cov0" title="0">{
                return nil, errors.New("duplicated account")
        }</span>

        <span class="cov0" title="0">account, accountError := entity.CreateAccount(input.Name, input.Email, input.Cpf, input.CarPlate, input.IsPassenger, input.IsDriver)

        if accountError != nil </span><span class="cov0" title="0">{
                return nil, accountError
        }</span>

        <span class="cov0" title="0">s.AccountRepository.SaveAccount(account)

        output := SignupOutput{
                AccountId: account.AccountId,
        }

        return &amp;output, nil</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package usecase

import (
        "errors"

        "github.com/google/uuid"
        "github.com/leonardograselalmeida/fake_uber/internal/application/repository"
)

type StartRide struct {
        RideRepository repository.RideRepositoryInterface
}

type StartRideInput struct {
        RideId uuid.UUID
}

func (s *StartRide) Execute(input StartRideInput) error <span class="cov0" title="0">{
        ride, rideError := s.RideRepository.GetRideById(input.RideId)
        if rideError != nil </span><span class="cov0" title="0">{
                return rideError
        }</span>
        <span class="cov0" title="0">if ride == nil </span><span class="cov0" title="0">{
                return errors.New("ride not found")
        }</span>
        <span class="cov0" title="0">ride.Start()
        s.RideRepository.UpdateRide(ride)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package entity

import (
        "errors"
        "regexp"

        "github.com/google/uuid"
        "github.com/leonardograselalmeida/fake_uber/internal/domain"
)

type Account struct {
        AccountId   uuid.UUID
        Name        string
        Email       string
        Cpf         string
        CarPlate    string
        IsPassenger bool
        IsDriver    bool
}

func newAccount(accountId uuid.UUID, name string, email string, cpf string, carPlate string, isPassenger bool, isDriver bool) (*Account, error) <span class="cov8" title="1">{
        if isInvalidName(name) </span><span class="cov8" title="1">{
                err := errors.New("invalid name")
                return nil, err
        }</span>

        <span class="cov8" title="1">if isInvalidEmail(email) </span><span class="cov8" title="1">{
                err := errors.New("invalid email")
                return nil, err
        }</span>

        <span class="cov8" title="1">if !domain.ValidateCpf(cpf) </span><span class="cov8" title="1">{
                err := errors.New("invalid cpf")
                return nil, err
        }</span>

        <span class="cov8" title="1">if isDriver &amp;&amp; isInvalidCarPlate(carPlate) </span><span class="cov8" title="1">{
                err := errors.New("invalid car plate")
                return nil, err
        }</span>

        <span class="cov8" title="1">account := &amp;Account{
                AccountId:   accountId,
                Name:        name,
                Email:       email,
                Cpf:         cpf,
                CarPlate:    carPlate,
                IsPassenger: isPassenger,
                IsDriver:    isDriver,
        }

        return account, nil</span>
}

func CreateAccount(name string, email string, cpf string, carPlate string, isPassenger bool, isDriver bool) (*Account, error) <span class="cov8" title="1">{
        accountId := uuid.New()
        account, err := newAccount(accountId, name, email, cpf, carPlate, isPassenger, isDriver)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return account, nil</span>
}

func RestoreAccount(accountId uuid.UUID, name string, email string, cpf string, carPlate string, isPassenger bool, isDriver bool) (*Account, error) <span class="cov8" title="1">{
        account, err := newAccount(accountId, name, email, cpf, carPlate, isPassenger, isDriver)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return account, nil</span>
}

func isInvalidName(name string) bool <span class="cov8" title="1">{
        regex := regexp.MustCompile(`[a-zA-Z] [a-zA-Z]`)
        return !regex.MatchString(name)
}</span>

func isInvalidEmail(email string) bool <span class="cov8" title="1">{
        regex := regexp.MustCompile(`^(.+)@(.+)$`)
        return !regex.MatchString(email)
}</span>

func isInvalidCarPlate(carPlate string) bool <span class="cov8" title="1">{
        regex := regexp.MustCompile(`[A-Z]{3}[0-9]{4}`)
        return !regex.MatchString(carPlate)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

const (
        StatusRequested = "requested"
        StatusInProgres = "in_progress"
        StatusAccept    = "accept"
)

type Ride struct {
        RideId      uuid.UUID
        PassengerId uuid.UUID
        driverId    uuid.UUID
        status      string
        Date        time.Time
        FromLat     float64
        FromLong    float64
        ToLat       float64
        ToLong      float64
}

func newRide(rideId uuid.UUID, passengerId uuid.UUID, driverId uuid.UUID, status string, date time.Time, fromLat float64, fromLong float64, toLat float64, toLong float64) *Ride <span class="cov8" title="1">{
        ride := Ride{
                RideId:      rideId,
                PassengerId: passengerId,
                driverId:    driverId,
                status:      status,
                Date:        date,
                FromLat:     fromLat,
                FromLong:    fromLong,
                ToLat:       toLat,
                ToLong:      toLong,
        }

        return &amp;ride
}</span>

func CreateRide(passengerId uuid.UUID, fromLat float64, fromLong float64, toLat float64, toLong float64) *Ride <span class="cov8" title="1">{
        var driverId uuid.UUID
        rideId := uuid.New()
        status := StatusRequested
        currentTime := time.Now()
        ride := newRide(rideId, passengerId, driverId, status, currentTime, fromLat, fromLong, toLat, toLong)
        return ride
}</span>

func RestoreRide(rideId uuid.UUID, passengerId uuid.UUID, driverId uuid.UUID, status string, date time.Time, fromLat float64, fromLong float64, toLat float64, toLong float64) *Ride <span class="cov0" title="0">{
        ride := newRide(rideId, passengerId, driverId, status, date, fromLat, fromLong, toLat, toLong)
        return ride
}</span>

func (ride *Ride) Accept(driverId uuid.UUID) <span class="cov8" title="1">{
        ride.driverId = driverId
        ride.status = StatusAccept
}</span>

func (ride *Ride) Start() <span class="cov8" title="1">{
        ride.status = StatusInProgres
}</span>

func (ride *Ride) GetStatus() string <span class="cov8" title="1">{
        return ride.status
}</span>

func (ride *Ride) GetDriverId() uuid.UUID <span class="cov8" title="1">{
        return ride.driverId
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package domain

import (
        "regexp"
        "strconv"
        "strings"
)

func ValidateCpf(cpf string) bool <span class="cov8" title="1">{
        if cpf == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">cpf = cleanSpecialCaracteres(cpf)

        if isInvalidLength(cpf) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if allDigitsAreTheSame(cpf) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">digit1 := calculateDigit(cpf, 10)
        digit2 := calculateDigit(cpf, 11)

        return extractCheckDigit(cpf) == (strconv.Itoa(digit1) + strconv.Itoa(digit2))</span>
}

func cleanSpecialCaracteres(cpf string) string <span class="cov8" title="1">{
        regex := regexp.MustCompile(`\d+`)
        return strings.Join(regex.FindAllString(cpf, -1), "")
}</span>

func isInvalidLength(cpf string) bool <span class="cov8" title="1">{
        return len(cpf) != 11
}</span>

func allDigitsAreTheSame(cpf string) bool <span class="cov8" title="1">{
        caracteres := make(map[rune]int)

        for _, char := range cpf </span><span class="cov8" title="1">{
                caracteres[char]++
        }</span>

        <span class="cov8" title="1">for _, count := range caracteres </span><span class="cov8" title="1">{
                if count &lt;= 1 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func calculateDigit(cpf string, factor int) int <span class="cov8" title="1">{
        sum := 0

        for _, caracterer := range cpf </span><span class="cov8" title="1">{
                if factor &gt; 1 </span><span class="cov8" title="1">{
                        digit, _ := strconv.Atoi(string(caracterer))
                        sum += digit * factor
                        factor--
                }</span>
        }

        <span class="cov8" title="1">rest := sum % 11

        if rest &lt; 2 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return 11 - rest</span>
}

func extractCheckDigit(cpf string) string <span class="cov8" title="1">{
        return cpf[9:]
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
